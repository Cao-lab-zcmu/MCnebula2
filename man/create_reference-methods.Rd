% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-create_reference.R
\name{create_reference-methods}
\alias{create_reference-methods}
\alias{create_reference}
\alias{create_reference,mcnebula,ANY,ANY,ANY,ANY,logical,ANY-method}
\alias{create_reference,missing,missing,missing,missing,missing,missing,missing-method}
\alias{create_reference,mcnebula,missing,missing,missing,missing,missing,missing-method}
\alias{create_reference,mcnebula,character,missing,missing,missing,missing,missing-method}
\alias{create_reference,mcnebula,missing,character,missing,missing,missing,missing-method}
\alias{create_reference,mcnebula,missing,missing,data.frame,character,missing,missing-method}
\alias{create_reference,mcnebula,missing,missing,data.frame,integer,missing,missing-method}
\alias{create_reference,mcnebula,missing,missing,data.frame,missing,missing,missing-method}
\title{Establish 'specific candidate' for each 'feature'}
\usage{
\S4method{create_reference}{mcnebula,ANY,ANY,ANY,ANY,logical,ANY}(x, from, subscript, data, columns, fill, MoreArgs)

\S4method{create_reference}{missing,missing,missing,missing,missing,missing,missing}()

\S4method{create_reference}{mcnebula,missing,missing,missing,missing,missing,missing}(x)

\S4method{create_reference}{mcnebula,character,missing,missing,missing,missing,missing}(x, from)

\S4method{create_reference}{mcnebula,missing,character,missing,missing,missing,missing}(x, subscript)

\S4method{create_reference}{mcnebula,missing,missing,data.frame,character,missing,missing}(x, data, columns)

\S4method{create_reference}{mcnebula,missing,missing,data.frame,integer,missing,missing}(x, data, columns)

\S4method{create_reference}{mcnebula,missing,missing,data.frame,missing,missing,missing}(x, data)
}
\arguments{
\item{x}{\linkS4class{mcnebula} object.}

\item{from}{character(1). "structure", "formula" or "ppcp".}

\item{subscript}{character(1). ".f3_fingerid", ".f2_formula" or ".f3_canopus".
See \linkS4class{subscript}.}

\item{data}{data.frame. An external channel for user to specify candidate customarily.
Normally not used.}

\item{columns}{character(2) or numeric(2). Specify the key columns in the parameter
of data. Normally not used.}

\item{fill}{logical. If \code{TRUE}, run post modification.
Run \code{filter_formula(object)}, and use its results to fill the data
\code{specific_candidate} for 'features' without specified top candidate.
Only useful when the data \code{specific_candidate} were
based on scores of chemical structure or classes, as for some 'features'
there may be no chemical structural
or classified candidates but candidates for chemical formula.}

\item{MoreArgs}{list. Used only \code{fill = T}. Parameters passed to \code{\link[=filter_formula]{filter_formula()}}.}
}
\description{
According to the filtered data, whether obtained by \code{\link[=filter_formula]{filter_formula()}},
\code{\link[=filter_structure]{filter_structure()}} or \code{\link[=filter_ppcp]{filter_ppcp()}},
establishing specific candidate of each 'feature' for subsequent data filtering.
This step is an important intermediate link for the three part of data filtering,
makes the final filtered results of chemical formula, structure and classification
consistent.

\code{create_reference()}: get the default parameters for the method
\code{create_reference}.
}
\details{
\bold{Establish reference upon top candidate}
Suppose we predicted a potential compound represented by LC-MS/MS spectrum,
and obtained the candidates of chemical molecular formula,
structure and chemical class.
These candidates include both positive and negative results:
for chemical molecular formula and chemical structure,
the positive prediction was unique; for chemical class,
multiple positive predictions that belong to various classification were involved.
We did not know the exact negative and positive.
Normally, we ranked and filtered these according to the scores.
There were numerious scores, for isotopes, for mass error, for structural similarity,
for chemical classes...
Which score selected to rank candidates depends on the purpose
of research. Such as:
\itemize{
\item To find out the chemical structure mostly be positive, ranking the candidates
by structural score.
\item To determine whether the potential compound may be of a certain chemical classes,
ranking the candidates by the classified score.
}

Ether by \code{\link[=filter_formula]{filter_formula()}}, \code{\link[=filter_structure]{filter_structure()}} or \code{\link[=filter_ppcp]{filter_ppcp()}}, the
candidate with top score can be obtained.
However, for the three module (formula, structure, classes), sometimes
thier top score candidates were not in line with each other.
That is, thier top score towards different chemical molecular formulas.
To find out the corresponding data in other modules,
\code{create_reference} should be performed to establish the
'specific_candidate' for subsequent filtering.
}
\examples{
\dontrun{
  test <- mcn_5features
  
  ## set specific candidate
  ## ------------------------------------- 
  ## from chemical structure
  test1 <- filter_structure(test)
  test1 <- create_reference(test1)
  ## see results
  specific_candidate(test1)
  ## or
  reference(test1)$specific_candidate
  ## or
  reference(mcn_dataset(test1))$specific_candidate
  ## 'create_reference(test1)' equals to
  test1 <- create_reference(test1, from = "structure", fill = T)
  e1 <- specific_candidate(test1)
  
  ## the above equals to following:
  data <- latest(filter_structure(test1))
  test1 <- create_reference(test1, data = data, fill = T)
  e2 <- specific_candidate(test1)
  identical(e1, e2)
  
  ## the 'specific_candidate' data used for filtering
  test1 <- filter_formula(test1, by_reference = T)
  
  ## ------------------------------------- 
  ## from chemical formula
  test1 <- filter_formula(test1)
  test1 <- create_reference(test1, from = "formula")
  
  ## ------------------------------------- 
  ## from chemical classes
  ## A complex example:
  ## suppose there were some classes we were interested in
  all_classes <- latest(test1, "project_dataset", ".canopus")$class.name
  set.seed(1)
  classes <- sample(all_classes, 50)
  classes
  test1 <- filter_ppcp(test1,
    dplyr::filter,
    class.name \%in\% classes,
    pp.value > 0.5,
    by_reference = F
  )
  data <- latest(test1)
  data
  ## 'feature' have a plural number of candidates.
  ids <- data$.features_id
  id <- unique(ids[duplicated(ids)])
  ## get the candidate of top chemical structural score.
  `\%>\%` <- magrittr::`\%>\%`
  candidates <- filter_structure(test1, dplyr::filter, .features_id \%in\% id) \%>\% 
    latest() \%>\% 
    dplyr::filter(.candidates_id \%in\% data$.candidates_id) \%>\% 
    dplyr::arrange(.features_id, dplyr::desc(csi.score)) \%>\% 
    dplyr::distinct(.features_id, .keep_all = T)
  ## for refecrence
  data <- data \%>\%
    dplyr::filter(
      .features_id != candidates$.features_id |
        (.features_id == candidates$.features_id &
          .candidates_id == candidates$.candidates_id)
    )
  test1 <- create_reference(test1, data = data, fill = T)
  specific_candidate(test1)
  
}
}
